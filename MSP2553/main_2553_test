#include <msp430.h> 
#include <string.h>

/*
 * Fonction qui permet d'initialiser les ports du SPI
 */
void InitSPI_Port(void)
{
	P1DIR |= BIT0 ;
	P1OUT &=~ BIT0;

	P1SEL |= (BIT1 + BIT2 +BIT4);
	P1SEL2 |= (BIT1 + BIT2 +BIT4);
}

/*
 * Fonctionn permettant d'initialiser les registres du SPI
 */
void InitSPI_mode(void)
{
	/*
	 * La polarité est configuré par le registre UCCKPL
	 * on configure le sens de direction de l'envoie du bit ici le bit de poid fort en premier
	 */

	UCA0CTL0 |=  UCMSB + UCSYNC;
	//UCA0CTL0 |= UCCKPL;
	UCA0CTL1 &=~ UCSWRST;

	/*
	 * enable USCIO RX interrupt
	 */
	IE2 |= UCA0RXIE;
}

/*
 * Fonction permettant de transmettre un caractère au maitre
 */
void TXSPI_data(unsigned char c)
{
	while (!(IFG2 & UCA0TXIFG));
	UCA0TXBUF=2*c;
}

/*
 * Fonction permettant de recevoir un caractère du maitre
 */

unsigned char RXSPI_data()
{
	//while (!(IFG2 & UCA0RXIFG));
	return UCA0RXBUF;
}

void Send_data(char *point, int taille)
{
	int i=0;
	for (i=0;i<taille;i++)
	{
		TXSPI_data((unsigned char)point[i]);
	}
}
void Send_data_test()
{
	TXSPI_data('e');
	.
	
	TXSPI_data('2');
	TXSPI_data('3');
}
int main(void)
{
    WDTCTL = WDTPW + WDTHOLD;	// Stop watchdog timer
    InitSPI_Port();
    InitSPI_mode();
    __enable_interrupt();
    while(1);
}

#pragma vector = USCIAB0RX_VECTOR
__interrupt void USCI0RX_ISR(void)
{
	unsigned char tamp;
	//char send_data[100];
	//unsigned char test;
	if (IFG2 & UCA0RXIFG)
	{
		tamp=	UCA0RXBUF;
		if (tamp & 0x60)
		{
			P1OUT ^= BIT0;
			//test = '1023';
			//TXSPI_data(test);
			Send_data_test();
			//send_data[2]= 'le';
			//Send_data(send_data, strlen(send_data));
		}
		else
		{
			P1OUT &=~ BIT0;
		}

	}
}
